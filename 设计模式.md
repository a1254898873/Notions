# 设计模式

## UML中常见关系

### 泛化

泛化（generalization）关系时指一个类（子类、子接口）继承另外一个类（称为父类、父接口）的功能，又名继承，并可以增加它自己新功能的能力，继承是类与类或者接口与接口最常见的关系，在Java中通过关键字extends来表示。

 ![img](https://raw.githubusercontent.com/a1254898873/images/master/202203240116519.png)

### 实现

实现（realization）是指一个class实现interface接口（一个或者多个），表示类具备了某种能力，实现是类与接口中最常见的关系，在Java中通过implements关键字来表示。

 ![img](https://raw.githubusercontent.com/a1254898873/images/master/202203240116520.png)

### 依赖

依赖（dependency）关系也是表示类与类之间的连接，表示一个类依赖于另外一个类的定义，依赖关系时是单向的。简单理解就是类A使用到了类B，这种依赖具有偶然性、临时性，是非常弱的关系。但是类B的变化会影响到类A。举个例子，如某人要过河，则人与船的关系就是依赖，人过河之后，与船的关系就解除了，因此是一种弱的连接。在代码层面，为类B作为参数被类A在某个方法中使用。

在java中，依赖表现为：局部变量，方法中的参数和对静态方法的调用。

 ![img](https://raw.githubusercontent.com/a1254898873/images/master/202203240116521.png)

### 关联

关联（association）关系表示类与类之间的连接，它使得一个类知道另外一个类的属性和方法。

关联可以使用单箭头表示单向关联，使用双箭头或者不适用箭头表示双向关联，不建议使用双向关联，关联有两个端点，每个端点可以有一个基数，表示这个关联的类可以有几个实例。

0..1 表示可以有0个或者1个实例

0..* 表示对实例的数目没有限制

1   表示只能有一个实例

1..* 表示至少有一个实例

关联关系体现的是两个类，或者类与接口之间的强依赖关系，这种关系很强烈，比依赖更强，不是偶然性的，也不是临时性的，而是一种长期性，相对平等的关系，表现在代码层面，为被关联的类B以类属性的形式出现在类A中，也可能是关联类A引用了被关联类B的全局变量。

在Java中，关联关系是使用实例变量来实现的

 ![img](https://raw.githubusercontent.com/a1254898873/images/master/202203240116522.png)

### 聚合

聚合（aggregation）是关联关系的特例，是强的关联关系，聚合是整个与个体的关系，即has-a关系，此时整体和部分是可以分离的，他们具有各自的生命周期，部分可以属于多个对象，也可以被多个对象共享；比如计算机和CPU，公司与员工的关系；在代码层面聚合与关联是一致的，只能从语义上来区分。

聚合关系也是使用实例变量来实现的，在java语法上区分不出关联和聚合，关联关系中类出于一个层次，而聚合则明显的在两个不同的层次。

 ![img](https://raw.githubusercontent.com/a1254898873/images/master/202203240116523.png)

### 组合

组合（compostion）也是关联关系的一种特例，体现的是一种contain-a关系，比聚合更强，是一种强聚合关系。它同样体现整体与部分的关系，但此时整体与部分是不可分的，整体生命周期的结束也意味着部分生命周期的结束，反之亦然。如大脑和人类。

体现在代码层面与关联时一致的，只能从语义来区分。

组合与聚合几乎完全相同，唯一区别就是对于组合，“部分”不同脱离“整体”单独存在，其生命周期应该是一致的。

 ![img](https://raw.githubusercontent.com/a1254898873/images/master/202203240116524.png)

## 六大原则

### 单一职责原则(Single Responsibility Principle)

一个类只负责一项职责，不能将太多的职责放在一个类中

### 开闭原则（Open Close Principle）

对扩展开放，对修改关闭。

### 里氏替换原则（Liskov Substitution Principle）

只要父类能出现的地方子类就能出现。反之，父类则未必能胜任。

### 依赖倒置原则（Dependence Inversion Principle）

面向接口编程，变量的表面类型尽量是接口或者抽象类

### 接口隔离原则（InterfaceSegregation Principles）

建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。

### 迪米特原则（Law of Demeter）

 一个类对自己依赖的类知道的越少越好。



有时也会说七大原则，还有一个合成复用原则



## 行为模式

### 策略模式

#### 定义

定义一系列算法，把他们一个个封装起来，并且使他们相互可以替换。本模式使得算法可以独立于使用它的客户而变化。策略模式封装的是算法，而状态模式侧重的对象状态的转变。
策略模式经常会和静态工厂模式一起使用,把各个算法的创建放到工厂之中。

![img](https://raw.githubusercontent.com/a1254898873/images/master/202203240116525.png)

#### 应用

1、封装业务算法

背景：做一次运营活动，双十一充值会员打折活动，回馈老会员，根据会员的不同等级使用不同的定价策略

```java
/**
 * 策略，定义计算报价算法的接口
 */
public interface Strategy {
    /**
     * 计算应报的价格
     * @param goodsPrice 商品销售原价
     * @return 计算出来的，应该给客户报的价格
     */
    public double calcPrice(double goodsPrice);
}
```

```java
/**
 * 具体算法实现，为新客户或者是普通客户计算应报的价格
 */
public class NormalCustomerStrategy implements Strategy{
    public double calcPrice(double goodsPrice) {
        System.out.println("对于新客户或者是普通客户，没有折扣");
        return goodsPrice;
    }
}


/**
 * 具体算法实现，为老客户计算应报的价格
*/
public class OldCustomerStrategy implements Strategy{
    public double calcPrice(double goodsPrice) {
        System.out.println("对于老客户，统一折扣5%");
        return goodsPrice*(1-0.05);
    }
}

/**
 * 具体算法实现，为大客户计算应报的价格
 */
public class LargeCustomerStrategy implements Strategy{
    public double calcPrice(double goodsPrice) {
        System.out.println("对于大客户，统一折扣10%");
        return goodsPrice*(1-0.1);
    }
}
```

创建上下文：

```java
/**
 * 价格管理，主要完成计算向客户所报价格的功能
 */
public class Price {
    /**
     * 持有一个具体的策略对象
     */
    private Strategy strategy = null;
    /**
     * 构造方法，传入一个具体的策略对象
     * @param aStrategy 具体的策略对象
     */
    public Price(Strategy aStrategy){
        this.strategy = aStrategy;
    }  
    /**
     * 报价，计算对客户的报价
     * @param goodsPrice 商品销售原价
     * @return 计算出来的，应该给客户报的价格
     */
    public double quote(double goodsPrice){
        return this.strategy.calcPrice(goodsPrice);
    }
}
```

客户端调用：

```java
public class Client {
    public static void main(String[] args) {
        //1：选择并创建需要使用的策略对象
        Strategy strategy = new LargeCustomerStrategy ();
        //2：创建上下文
        Price ctx = new Price(strategy);

        //3：计算报价
        double quote = ctx.quote(1000);
        System.out.println("向客户报价："+quote);
    }
}
```

2、实现自己的比较器

定义比较器接口

```java
public interface Comparator<T> {
 int compare(T t1, T t2);
}
```

根据狗的身高排序的算法

```java
public class DogHeightComparator implements Comparator<Dog> {
 @Override
 public int compare(Dog t1, Dog t2) {
 return t1.height - t2.height;
 }
}
```

根据猫的体重排序算法：

```java
public class CatWeightComparator implements Comparator<Cat> {
 @Override
 public int compare(Cat t1, Cat t2) {
 return t1.weight - t2.weight;
 }
}
```

定义排序类
使用泛型和冒泡排序完成排序逻辑，sort方法调用的时候需要把上面定义的比较器对象传入

```java
public class Sort <T> {
 public void sort(T[] array, Comparator<T> comparator){
 //使用冒泡排序算法进行排序
 for(int i = 0; i < array.length; i++){
 for(int k = 0; k < array.length - 1 - i; k++ ){
 if(comparator.compare(array[k], array[k+1]) > 0){
 swap(array, k, k+1);
 }
 }
 }
 }
 private void swap(T[] arr, int m,int n){
 T temp = arr[m];
 arr[m] = arr[n];
 arr[n] = temp;
 }
}
```

如何使用？

```java
public static void main(String[] args) {
 Dog dog1 = new Dog(20,30);
 Dog dog2 = new Dog(19,31);
 Dog dog3 = new Dog(13,32);
 Dog[] dogs = new Dog[]{dog1,dog2,dog3};

 Sort<Dog> sortor = new Sort();
 sortor.sort( dogs, new DogHeightComparator());

 System.out.println(Arrays.toString(dogs));
 }
```



### 观测者模式

#### 定义

又名发布订阅模式，定义对象一对多的依赖关系，当一个对象状态发生改变时，所有依赖于它的对象都得到通知并自动更新

![img](https://raw.githubusercontent.com/a1254898873/images/master/202203240116526.jpg)

#### 应用

JDK已经帮我们定义好了观察者模式的接口(java.util.Observale;java.util.Observer)，我们如果项目中需要使用观察者模式，只需简单继承一下就可以了,JDK保证了线程安全。

Observable对象（被观察者）维护了一个观察者集合(Vector(Observer))，通过回调通知观察者，
主要方法：

1. notifyObservers 通知所有的观察者
2. addObserver 增加新的观察者

下面的代码来自JDK源码（java.util包下）

```java
public class Observable {
    private boolean changed = false;
    private Vector<Observer> obs;

    /** Construct an Observable with zero Observers. */

    public Observable() {
        obs = new Vector<>();
    }
    public synchronized void addObserver(Observer o) {
        if (o == null)
            throw new NullPointerException();
        if (!obs.contains(o)) {
            obs.addElement(o);
        }
    }
    public synchronized void deleteObserver(Observer o) {
        obs.removeElement(o);
    }

    public void notifyObservers() {
        notifyObservers(null);
    }


    public void notifyObservers(Object arg) {
        /*
         * a temporary array buffer, used as a snapshot of the state of
         * current Observers.
         */
        Object[] arrLocal;

        synchronized (this) {
            /* We don't want the Observer doing callbacks into
             * arbitrary code while holding its own Monitor.
             * The code where we extract each Observable from
             * the Vector and store the state of the Observer
             * needs synchronization, but notifying observers
             * does not (should not).  The worst result of any
             * potential race-condition here is that:
             * 1) a newly-added Observer will miss a
             *   notification in progress
             * 2) a recently unregistered Observer will be
             *   wrongly notified when it doesn't care
             */
            if (!changed)
                return;
            arrLocal = obs.toArray();
            clearChanged();
        }

        for (int i = arrLocal.length-1; i>=0; i--)
            ((Observer)arrLocal[i]).update(this, arg);
    }

    /**
     * Clears the observer list so that this object no longer has any observers.
     */
    public synchronized void deleteObservers() {
        obs.removeAllElements();
    }

    protected synchronized void setChanged() {
        changed = true;
    }

    protected synchronized void clearChanged() {
        changed = false;
    }


    public synchronized boolean hasChanged() {
        return changed;
    }
    public synchronized int countObservers() {
        return obs.size();
    }
}
```

Observer 对象需要实现的方法 update()，供Observable回调使用。

```java
public interface Observer {
    /**
     * This method is called whenever the observed object is changed. An
     * application calls an <tt>Observable</tt> object's
     * <code>notifyObservers</code> method to have all the object's
     * observers notified of the change.
     *
     * @param   o     the observable object.
     * @param   arg   an argument passed to the <code>notifyObservers</code>
     *                 method.
     */
    void update(Observable o, Object arg);
}
```

基于JDK的Observer和Obserable来实现观察者模式

首先，定义一个读者对象，他是一个观察者的角色。

```java
public class Reader implements Observer {  

    @Override  
    public void update(Observable arg0, Object arg1) {  

        if(arg0 instanceof Publisher){ 
            Publisher publisher = (Publisher)arg0;  
            System.out.println("有新杂志。我要订阅"+publisher.getMagazineName());  
        }  
    }  
}  
```

然后我们定义发布者对象

```java
public class Publisher extends Observable{


    private String magazineName;
    public String getMagazineName() {
        return magazineName;
    }
    public void setMagazineName(String magazineName) {
        this.magazineName = magazineName;
    }
    public void publish (String magazineName){
        this.magazineName = magazineName;

        this.setChanged();
          /**
            * 这个地方notifyObservers的参数可以是任意想传递给订阅者的对象
           **/
        this.notifyObservers(this);

    }

}
```

模拟场景：

```java
        Publisher publisher  = new Publisher();  

        Reader  zhangsan = new Reader();  
        publisher.addObserver(zhangsan);  

        Reader  lisi = new Reader();  
        publisher.addObserver(lisi);  

        publisher.publish("程序员第0321期");  
```













### 责任链模式

#### 定义

责任链模式为请求创建一个接收者对象链，每个接收者都包含对另一个接收者的引用，如果一个对象不能处理该请求，那么它会把请求传给下一个接收者，依此类推
责任链模式避免了请求的发送者和接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连成一条链，并且沿着这条链传递请求，直到有对象处理它为止。

![img](https://raw.githubusercontent.com/a1254898873/images/master/202203240116527.png)

如上图，员工提出请假请求，这个请求会在项目经理、项目主管、部门经理的整个链条传递，根据请假时长决定由哪个领导审批。

![img](https://raw.githubusercontent.com/a1254898873/images/master/202203240116528.png)

#### 应用

一、springsecurity的filter

1、通过处理器集合来定义处理顺序

好处在于可以集中管理处理器，指责单一。非常容易理解，容易实现。缺点是如果新增处理器（Handler）势必影响已有的处理器，只能顺序执行。处理流程是这样的:

![img](https://raw.githubusercontent.com/a1254898873/images/master/202203240116529.png)

接下来用代码来实现一下此模式：

HandlerChain 负责维护调用链条的顺序，这里默认实现用List来管理Handler

```java
public interface HandlerChain {
    /**
     * 调用handler 处理 source.
     *
     * @param requestSource the request source
     */
    void doChain(RequestSource requestSource);
}

// 实现
public class DefaultHandlerChain implements HandlerChain {
    // 当前handler指针的位置
    private int pos = 0;
    private List<Handler> handlers = new ArrayList<>();


    public void addHandler(Handler handler) {
        handlers.add(handler);
    }

    @Override
    public void doChain(RequestSource requestSource) {
        int size = handlers.size();
        if (pos < size) {
          //注意对pos的处理
            Handler handler = handlers.get(pos++);
            handler.doHandler(requestSource, this);
        }
    }
}
```

Handler是处理链的节点抽象，是数据源（RequestSource）的具体处理者，它负责对数据的处理以及决定是否进入下一个Handler。

```java
public interface Handler {
    /**
     * Do handler.
     *
     * @param requestSource  数据源
     * @param handlerChain   传入当前的Chain进行类似递归式的调用。
     */
    void doHandler(RequestSource requestSource,HandlerChain handlerChain);
}

// 其中一个实现
public class HeaderHandler implements Handler {
    @Override
    public void doHandler(RequestSource requestSource, HandlerChain handlerChain) {
       // 处理数据
        Integer header = requestSource.getHeader();
        System.out.println("header handler= " + header);
       //继续下一个 你可以根据条件来决定是否继续进行chain
        handlerChain.doChain(requestSource);
    }
}
```

2、利用链表的指针特性

![img](https://raw.githubusercontent.com/a1254898873/images/master/202203240116531.png)

Handler负责指针以及逻辑处理：

```java
public interface Handler {
    /**
     * 指针指向下一个处理节点.
     *
     * @return the next
     */
    Handler getNext();

    /**
     * 处理具体逻辑.
     *
     * @param requestSource the request source
     */
    void doHandler(RequestSource requestSource);
}

// 实现
public class HeaderHandler implements Handler {
    private Handler next;

    public HeaderHandler(Handler next) {
        this.next = next;
    }

    @Override
    public Handler getNext() {
        return next;
    }

    @Override
    public void doHandler(RequestSource requestSource) {
        Integer header = requestSource.getHeader();
        System.out.println("header = " + header);
        if (next != null) {
            next.doHandler(requestSource);
        }
    }
}
```







### 状态模式

#### 定义

允许一个对象在其内部状态改变时改变它的行为

![img](https://raw.githubusercontent.com/a1254898873/images/master/202203240116532.png)

#### 比较

1、与策略模式比较

两个都是多态的应用

策略模式：封装算法，让使用者可以更换不同的算法。变is a为has a 用组合来代替继承。一旦置入算法，不会因使用者的内部状态来改变算法。 采用哪种算法，是由使用者掌握的。

状态模式：对象的内部状态决定它的行为。不同的状态有不同的行为，不同的行为又切换不同的状态。 当方法内出现很多if else时可以考虑使用状态模式。状态模式重要的一点是在行为执行时，状态的变更。



2、与责任链模式比较

状态模式和责任链模式都能消除 if-else 分支过多的问题。但在某些情况下，状态模式中的状态可以理解为责任，那么在这种情况下，两种模式都可以使用。

从定义来看，状态模式强调的是一个对象内在状态的改变，而责任链模式强调的是外部节点对象间的改变。

从代码实现上来看，两者最大的区别就是状态模式的各个状态对象知道自己要进入的下一个状态对象，而责任链模式并不清楚其下一个节点处理对象，因为链式组装由客户端负责。



#### 应用

订单有 待付款、待出库、待收货、待评价 4种状态

订单状态接口

```java
public interface OrderState {
    void handle(Context context);
}
```

各个状态的实现

```java
public class PendingPaymentState implements OrderState {
    @Override
    public void handle(Context context) {
        System.out.println("处理待付款状态的逻辑");
        context.setOrderState(new WaitOutStockState());
    }
}

public class WaitOutStockState implements OrderState {

    @Override
    public void handle(Context context) {
        System.out.println("等待出库的状态");
        context.setOrderState(new PendingDeliveryOrder());
    }
}

public class PendingDeliveryOrder implements OrderState {
    @Override
    public void handle(Context c) {
        System.out.println("待收货状态");
        c.setOrderState(new PendingEvaluation());
    }
}


public class PendingEvaluation implements OrderState {

    @Override
    public void handle(Context context) {
        System.out.println("待评价状态");
        context.setOrderState(null);
    }
}
```

如何进行状态的切换

```java
public static void main(String[] args) {
        OrderState orderState = new PendingPaymentState();
        Context context = new Context(orderState);
        context.handle(context);


        context.handle(context);


        context.handle(context);

        context.handle(context);


        context.handle(context);
    }
```



### 中介者模式

#### 定义

用一个中介对象来封装一系列的对象交换，它使各对象不需要显示地相互调用，从而达到低耦合

![../_images/Mediator.jpg](https://raw.githubusercontent.com/a1254898873/images/master/202203240116533.jpg)



#### 对比

外观模式：外观模式提供一个更高层的接口，给调用系统提供统一的接口服务，对外隐藏子系统的实现，隔离变化（其实就是依赖抽象）。侧重的是组合一批对象对外提供接口服务。

中介者模式：侧重的是将多对多的通信转化为一对多的通信





#### 应用

1、ORM框架的实现

![场景模拟；模仿Mybatis手写ORM框架](https://raw.githubusercontent.com/a1254898873/images/master/202203240116534.jpg)



2、MVC模式中，Controller 是中介者，根据 View 层的请求来操作 Model 层



3、数据库同步

有三种数据库 Mysql、Redis、Elasticsearch，其中的 Mysql 作为主数据库，当增加一条数据时需要同步到另外两个数据库中；Redis 作为缓存数据库，当增加一条数据时不需要同步到另外另个数据库；而 Elasticsearch 作为大数据查询数据库，有一个统计功能，当增加一条数据时只需要同步到 Mysql

![简化的数据同步需求](https://raw.githubusercontent.com/a1254898873/images/master/202203240116535.awebp)

![示例.中介者模式](https://raw.githubusercontent.com/a1254898873/images/master/202203240116536.awebp)

首先是抽象数据库类（抽象同事类），维护了一个中介者

```java
public abstract class AbstractDatabase {
    public static final String MYSQL = "mysql";
    public static final String REDIS = "redis";
    public static final String ELASTICSEARCH = "elasticsearch";

    protected AbstractMediator mediator;    // 中介者

    public AbstractDatabase(AbstractMediator mediator) {
        this.mediator = mediator;
    }

    public abstract void addData(String data);

    public abstract void add(String data);
}

```

Mysql 数据库（具体同事类）

```java
public class MysqlDatabase extends AbstractDatabase {
    private List<String> dataset = new ArrayList<String>();

    public MysqlDatabase(AbstractMediator mediator) {
        super(mediator);
    }

    @Override
    public void addData(String data) {
        System.out.println("Mysql 添加数据：" + data);
        this.dataset.add(data);
    }

    @Override
    public void add(String data) {
        addData(data);
        this.mediator.sync(AbstractDatabase.MYSQL, data); // 数据同步作业交给中介者管理
    }

    public void select() {
        System.out.println("Mysql 查询，数据：" + this.dataset.toString());
    }
}

```

Redis 数据库（具体同事类）

```java
public class RedisDatabase extends AbstractDatabase {
    private List<String> dataset = new LinkedList<String>();

    public RedisDatabase(AbstractMediator mediator) {
        super(mediator);
    }

    @Override
    public void addData(String data) {
        System.out.println("Redis 添加数据：" + data);
        this.dataset.add(data);
    }

    @Override
    public void add(String data) {
        addData(data);
        this.mediator.sync(AbstractDatabase.REDIS, data);    // 数据同步作业交给中介者管理
    }

    public void cache() {
        System.out.println("Redis 缓存的数据：" + this.dataset.toString());
    }
}

```

Elasticsearch（具体同事类）

```java
public class EsDatabase extends AbstractDatabase {
    private List<String> dataset = new CopyOnWriteArrayList<String>();

    public EsDatabase(AbstractMediator mediator) {
        super(mediator);
    }

    @Override
    public void addData(String data) {
        System.out.println("ES 添加数据：" + data);
        this.dataset.add(data);
    }

    @Override
    public void add(String data) {
        addData(data);
        this.mediator.sync(AbstractDatabase.ELASTICSEARCH, data);    // 数据同步作业交给中介者管理
    }

    public void count() {
        int count = this.dataset.size();
        System.out.println("Elasticsearch 统计，目前有 " + count + " 条数据，数据：" + this.dataset.toString());
    }
}

```

抽象中介者

```java
@Data
public abstract class AbstractMediator {
    protected MysqlDatabase mysqlDatabase;
    protected RedisDatabase redisDatabase;
    protected EsDatabase esDatabase;

    public abstract void sync(String databaseName, String data);
}

```

具体中介者

```java
public class SyncMediator extends AbstractMediator {
    @Override
    public void sync(String databaseName, String data) {
        if (AbstractDatabase.MYSQL.equals(databaseName)) {
            // mysql 同步到 redis 和 Elasticsearch
            this.redisDatabase.addData(data);
            this.esDatabase.addData(data);
        } else if (AbstractDatabase.REDIS.equals(databaseName)) {
            // redis 缓存同步，不需要同步到其他数据库
        } else if (AbstractDatabase.ELASTICSEARCH.equals(databaseName)) {
            // Elasticsearch 同步到 Mysql
            this.mysqlDatabase.addData(data);
        }
    }
}

```

测试客户端

```java
public class Client {
    public static void main(String[] args) {
        AbstractMediator syncMediator = new SyncMediator();
        MysqlDatabase mysqlDatabase = new MysqlDatabase(syncMediator);
        RedisDatabase redisDatabase = new RedisDatabase(syncMediator);
        EsDatabase esDatabase = new EsDatabase(syncMediator);

        syncMediator.setMysqlDatabase(mysqlDatabase);
        syncMediator.setRedisDatabase(redisDatabase);
        syncMediator.setEsDatabase(esDatabase);

        System.out.println("\n---------mysql 添加数据 1，将同步到Redis和ES中-----------");
        mysqlDatabase.add("1");
        mysqlDatabase.select();
        redisDatabase.cache();
        esDatabase.count();

        System.out.println("\n---------Redis添加数据 2，将不同步到其它数据库-----------");
        redisDatabase.add("2");
        mysqlDatabase.select();
        redisDatabase.cache();
        esDatabase.count();

        System.out.println("\n---------ES 添加数据 3，只同步到 Mysql-----------");
        esDatabase.add("3");
        mysqlDatabase.select();
        redisDatabase.cache();
        esDatabase.count();
    }
}

```



### 模板方法模式

#### 定义

定义一个操作中的算法骨架，而将一些步骤延迟到子类中，使得子类可以不改变算法的结构即可重新定义算法的某些特定步骤

![img](https://raw.githubusercontent.com/a1254898873/images/master/202203240116537.png)



#### 应用

大家最开始做java web开发肯定是从servlet开始的， servlet这个地方就是应用了典型的模板方法模式。

首先我们定义父类，在其中封装算法逻辑

```java
public class HttpRequest {
    public String header;
    public String body;
}

public abstract  class HttpSevlet {

    public abstract  void doPost(HttpRequest request);
    public abstract  void doGet(HttpRequest request);

    public void doService(HttpRequest request){
        if(request.header.equals("post")){
            doPost(request);
        }
        if(request.header.equals("get")){
            doGet(request);
        }
    }
}
```

然后我们定义自己的LogInServlet实现具体的算法：

```java
//各个子类实现自己具体的逻辑：
public class LoginServlet extends HttpSevlet {


    public void doPost(HttpRequest request) {

    }

    public void doGet(HttpRequest request) {

    }
}
```



### 迭代器模式

#### 定义

提供一种方法来顺序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示

![img](https://raw.githubusercontent.com/a1254898873/images/master/202203240116538.png)



#### 应用

创建迭代器接口，统一规范迭代方法，参照java.util.Iterator接口，这个接口被很多JDK集合类的内部Itr实现,比如java.util.ArrayList.Itr

```java
public interface Iterator {
    void first();

    /**
     * 迭代方法：移动到下一个元素
     */

     void next();

    /**
     * 迭代方法：是否为最后一个元素
     */

     boolean isDone();

    /**
     * 迭代方法：返还当前元素
     */

     Object currentItem();
}
```

ConcreteIterator里面的ArrayList是我们自己实现的ArrayList(见下文)而不是JDK的ArrayList

```java
public class ConcreteIterator implements Iterator {

        private ArrayList agg;
        private int index = 0;
        private int size = 0;

        public ConcreteIterator(ArrayList agg) {
            this.agg = agg;
            this.size = agg.size();
            index = 0;
        }

        /**
         * 迭代方法：返还当前元素
         */
        @Override
        public Object currentItem() {
            return agg.getElement(index);
        }

        /**
         * 迭代方法：移动到第一个元素
         */
        @Override
        public void first() {

            index = 0;
        }

        /**
         * 迭代方法：是否为最后一个元素
         */
        @Override
        public boolean isDone() {
            return (index >= size);
        }

        /**
         * 迭代方法：移动到下一个元素
         */
        @Override
        public void next() {

            if (index < size) {
                index++;
            }
        }

}
```

自己的Arraylist

```java
public class ArrayList implements List {
    private Object[] objArray = null;

    /**
     * 构造方法，传入聚合对象的具体内容
     */
    public ArrayList(Object[] objArray) {
        this.objArray = objArray;
    }

    @Override
    public Iterator createIterator() {
        return new ConcreteIterator(this);
    }

    /**
     * 取值方法：向外界提供聚集元素
     */
    public Object getElement(int index) {

        if (index < objArray.length) {
            return objArray[index];
        } else {
            return null;
        }
    }

    /**
     * 取值方法：向外界提供聚集的大小
     */
    public int size() {
        return objArray.length;

    }
}
```

测试

```java
 public static void main(String[] args) {
        Object[] objArray = { "One", "Two", "Three", "Four", "Five", "Six" };
        // 创建聚合对象
        List agg = new ArrayList(objArray);
        // 循环输出聚合对象中的值
        Iterator it = agg.createIterator();
        while (!it.isDone()) {
            System.out.println(it.currentItem());
            it.next();
        }

    }
```



### 访问者模式

#### 定义

访问者模式是一种行为设计模式， 它能将算法与其所作用的对象隔离开来。

最复杂的设计模式，并且使用频率不高，《设计模式》的作者评价为：大多情况下，你不需要使用访问者模式，但是一旦需要使用它时，那就真的需要使用了。

![img](https://raw.githubusercontent.com/a1254898873/images/master/202203240116539.png)



#### 关键代码

在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。

```java

    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
```











### 备忘录模式

#### 定义

在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，从而可以在以后将该对象恢复到原先保存的状态。

![img](https://raw.githubusercontent.com/a1254898873/images/master/202203240116540.png)



#### 应用

1、浏览器回退

2、数据库备份与还原

3、浏览器撤销与重做

4、git版本管理







### 命令模式

#### 定义

命令模式是一种行为设计模式， 它可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。

![img](https://raw.githubusercontent.com/a1254898873/images/master/202203240116541.png)





## 结构型模式

### 代理模式

#### 定义

给某一个类提供一个代理类，代理类持有被代理类的引用，由代理类给调用者提供服务，或者说 被代理类 委托 代理者 提供服务。

![img](https://raw.githubusercontent.com/a1254898873/images/master/202203240116542.png)





#### 应用

被代理类

```java
public interface ITarget {
    void doSomething();
}


public class Target implements ITarget {

    public void doSomething() {
        System.out.println("donSomething...");
    }
}
```

1、实现权限管理的切面

```java
/**
 * 
 *
 * 权限切面
 */
public class Aspect4Permission implements ITarget{

    ITarget target;

    public Aspect4Permission(ITarget target){
        this.target = target;
    }


    public void doSomething() {
        checkPermission();
        target.doSomething();
    }

    private void checkPermission(){
        System.out.println("checkPermission.....");
    }
}
```

2.实现日志记录的代理类

```java
/**
 * 
 *
 * 日志切面
 */
public class Aspect4Log implements ITarget
{

    ITarget target;

    public Aspect4Log(ITarget target){
        this.target = target;
    }

    public void doSomething() {
        printLog();
        target.doSomething();
    }

    private void printLog(){
        System.out.println("printLog.....");
    }
}
```

```java
Target target = new Target();

Aspect4Log aspect4Log = new Aspect4Log(target);

aspect4Log.doSomething();
```

代理模式可以在不修改原有类的情况下，对类进行拓展，比继承更加灵活。但是在在代理者很多的时候会造成类膨胀，每一个代理者多需要单独定义一个类，动态代理可以解决这个问题。







### 装饰者模式

#### 定义

装饰模式是一种结构型设计模式， 允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。

![img](https://raw.githubusercontent.com/a1254898873/images/master/202203240116543.png)



#### 比较

代理模式通过组合实现功能增强和扩展，装饰器模式通过继承实现增强和扩展。



#### 应用

Java I/O中的装饰者模式

![Java I/O的作用图](https://raw.githubusercontent.com/a1254898873/images/master/202203240116544.awebp)

由上图可知在Java中应用程序通过输入流（InputStream）的Read方法从源地址处读取字节，然后通过输出流（OutputStream）的Write方法将流写入到目的地址。

流的来源主要有三种：本地的文件（File）、控制台、通过socket实现的网络通信

![InputStream部分类关系](https://raw.githubusercontent.com/a1254898873/images/master/202203240116545.awebp)

由上图可以看出只要继承了FilterInputStream的类就是装饰者类，可以用于包装其他的流，装饰者类还可以对装饰者和类进行再包装。

```java
import java.io.BufferedInputStream;
import java.io.DataInputStream;
import java.io.FileInputStream;
import java.io.IOException;
public class StreamDemo {
    public static void main(String[] args) throws IOException{
        DataInputStream in=new DataInputStream(new BufferedInputStream(new  FileInputStream("D:\\hello.txt")));
        while(in.available()!=0) {
            System.out.print((char)in.readByte());
        }
        in.close();
    }
}

```





### 享元模式

#### 定义

享元模式是一种结构型设计模式， 它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。

![img](https://raw.githubusercontent.com/a1254898873/images/master/202203240116546.png)



#### 应用

1、JAVA的String

Java中将String类定义为final（不可改变的），JVM中字符串一般保存在字符串常量池中，java会确保一个字符串在常量池中只有一个拷贝，这个字符串常量池在JDK6.0以前是位于常量池中，位于永久代，而在JDK7.0中，JVM将其从永久代拿出来放置于堆中。

```java
public class Main {
    public static void main(String[] args) {
        String s1 = "hello";
        String s2 = "hello";
        String s3 = "he" + "llo";
        String s4 = "hel" + new String("lo");
        String s5 = new String("hello");
        String s6 = s5.intern();
        String s7 = "h";
        String s8 = "ello";
        String s9 = s7 + s8;
        System.out.println(s1==s2);//true
        System.out.println(s1==s3);//true
        System.out.println(s1==s4);//false
        System.out.println(s1==s9);//false
        System.out.println(s4==s5);//false
        System.out.println(s1==s6);//true
    }
}

```

String类的final修饰的，以字面量的形式创建String变量时，jvm会在编译期间就把该字面量hello放到字符串常量池中，由Java程序启动的时候就已经加载到内存中了。这个字符串常量池的特点就是有且只有一份相同的字面量，如果有其它相同的字面量，jvm则返回这个字面量的引用，如果没有相同的字面量，则在字符串常量池创建这个字面量并返回它的引用。
s6中，s5.intern()方法能使一个位于堆中的字符串在运行期间动态地加入到字符串常量池中（字符串常量池的内容是程序启动的时候就已经加载好了），如果字符串常量池中有该对象对应的字面量，则返回该字面量在字符串常量池中的引用，否则，创建复制一份该字面量到字符串常量池并返回它的引用。因此s1==s6输出true。



2、JAVA的Integer

```java
    public static void main(String[] args) {
        Integer i1 = 12 ;
        Integer i2 = 12 ;
        System.out.println(i1 == i2);//true

        Integer b1 = 128 ;
        Integer b2 = 128 ;
        System.out.println(b1 == b2);//false
    }

```

Integer 默认先创建并缓存 -128 ~ 127 之间数的 Integer 对象，当调用 valueOf 时如果参数在 -128 ~ 127 之间则计算下标并从缓存中返回，否则创建一个新的 Integer 对象



### 适配器模式

#### 定义

适配器模式是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。

![img](https://raw.githubusercontent.com/a1254898873/images/master/202203240116547.png)



#### 应用

spring MVC中的适配器模式

Spring MVC中的适配器模式主要用于执行目标 Controller 中的请求处理方法。
在Spring MVC中，DispatcherServlet 作为用户，HandlerAdapter 作为期望接口，具体的适配器实现类用于对目标类进行适配，Controller 作为需要适配的类。

为什么要在 Spring MVC 中使用适配器模式？

Spring MVC的Handler（Controller接口，HttpRequestHandler，Servlet、@RequestMapping）有四种表现形式，在Handler不确定是什么方式的时候（可能是方法、也可能是类），适配器这种设计模式就能模糊掉具体的实现，从而就能提供统一访问接口。

```java
public interface HandlerAdapter {

	// 判断当前的这个HandlerAdapter  是否 支持给与的handler
	// 因为一般来说：每个适配器只能作用于一种处理器（你总不能把手机适配器拿去用于电脑吧）
	boolean supports(Object handler);
	
	// 核心方法：利用 Handler 处理请求，然后返回一个ModelAndView 
	// DispatcherServlet最终就是调用此方法，来返回一个ModelAndView的~
	@Nullable
	ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;
	// 同HttpServlet 的 getLastModified方法
	// Can simply return -1 if there's no support in the handler class.
	long getLastModified(HttpServletRequest request, Object handler);

}
```

HandlerAdapter的作用在于将request中的各个属性，如request param适配为handler能够处理的形式。参数绑定、数据校验、内容协商…几乎所有的web层问题都在在这里完成的。HandlerAdapter.handle()是执行真正开发者开发的处理方法的地方。

它的继承树：

![fnlzvtoafn](https://raw.githubusercontent.com/a1254898873/images/master/202203240116548.png)

1、SimpleControllerHandlerAdapter（基本弃用）

Controller它没有对参数的自动封装、校验等一系列高级功能，但是它保留有对ModelAndView的处理能力，这是区别Servlet这种处理器的地方。

2、HttpRequestHandlerAdapter

和上面的唯一不同是：return null。那是因为HttpRequestHandler#handleRequest()它没有返回值（全靠开发者自己写response），而Controller最起码来说还有Model和View自动渲染的能力嘛

3、SimpleServletHandlerAdapter

处理方式几乎同HttpRequestHandler，都是对源生请求进行直接处理。它的特殊之处在于：Spring MVC默认并不向容器注册这种HandlerAdapter，若需要使用是需要调用者手动给注册这个Bean，Servlet这种Handler才能正常使用的

4、AbstractHandlerMethodAdapter

这种处理器也是我们最为常用的。

```java
// @since 3.1 @RequestMapping注解是Spring2.5出现的
// 注意：它实现了Ordered接口
public abstract class AbstractHandlerMethodAdapter extends WebContentGenerator implements HandlerAdapter, Ordered {
	
	// 唯一构造函数。传的false表示：忽略掉supportedMethods这个属性
	// 默认它的值是GET、POST、HEAD（见WebContentGenerator）
	public AbstractHandlerMethodAdapter() {
		// no restriction of HTTP methods by default
		super(false);
	}

	// 只处理HandlerMethod 类型的处理器。抽象方法supportsInternal默认返回true
	// 是流出的钩子可以给你自己扩展的
	@Override
	public final boolean supports(Object handler) {
		return (handler instanceof HandlerMethod && supportsInternal((HandlerMethod) handler));
	}

	// 抽象方法交给子类handleInternal去实现
	@Override
	@Nullable
	public final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
		return handleInternal(request, response, (HandlerMethod) handler);
	}
	...
}
```

它有个大名鼎鼎的子类：RequestMappingHandlerAdapter。此子类已经把HandlerMethod的实现精确到了@RequestMapping注解方案。





### 外观模式

#### 定义

外观模式是一种结构型设计模式， 能为程序库、 框架或其他复杂类提供一个简单的接口。

<img src="http://static.oschina.net/uploads/space/2015/1126/003312_fO05_2003960.png" alt="003312_fO05_2003960.png" style="zoom: 50%;" />

#### 应用

SLF4J 是简单的日志外观模式框架，抽象了各种日志框架例如 Logback、Log4j、Commons-logging 和 JDK 自带的 logging 实现接口。它使得用户可以在部署时使用自己想要的日志框架。

SLF4J 没有替代任何日志框架，它仅仅是标准日志框架的外观模式。如果在类路径下除了 SLF4J 再没有任何日志框架，那么默认状态是在控制台输出日志。





### 组合模式

#### 定义

组合模式是一种结构型设计模式， 你可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。

![img](https://raw.githubusercontent.com/a1254898873/images/master/202203240116549.png)







### 桥接模式

#### 定义

桥接模式是一种结构型设计模式， 可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。

![img](https://raw.githubusercontent.com/a1254898873/images/master/202203240116550.webp)



#### 应用

JDBC的应用

我们在刚开始用 JDBC 直连数据库的时候，会有这样一段代码：

```java
Class.forName("com.mysql.cj.jdbc.Driver");//加载及注册JDBC驱动程序
String url = "jdbc:mysql://localhost:3306/sample_db?user=root&password=your_password";
Connection con = DriverManager.getConnection(url);
Statement stmt = con.createStatement()；
String query = "select * from test";
ResultSet rs=stmt.executeQuery(query);
while(rs.next()) {
  rs.getString(1);
  rs.getInt(2);
}
```

如果我们想要把 MySQL 数据库换成 Oracle 数据库，只需要把第一行代码中的 com.mysql.cj.jdbc.Driver 换成oracle.jdbc.driver.OracleDriver 就可以了。

这种优雅的实现数据库切换方式就是利用了桥接模式。

我们首先看 Driver 类：

```java
public class Driver extends NonRegisteringDriver implements java.sql.Driver {
    public Driver() throws SQLException {
    }

    static {
        try {
            DriverManager.registerDriver(new Driver());
        } catch (SQLException var1) {
            throw new RuntimeException("Can't register driver!");
        }
    }
}
```

接着我们看 DriverManager 类：

```java
public class DriverManager {
  private final static CopyOnWriteArrayList<DriverInfo> registeredDrivers = new CopyOnWriteArrayList<DriverInfo>();

  //...
  static {
    loadInitialDrivers();
    println("JDBC DriverManager initialized");
  }
  //...

  public static synchronized void registerDriver(java.sql.Driver driver) throws SQLException {
    if (driver != null) {
      registeredDrivers.addIfAbsent(new DriverInfo(driver));
    } else {
      throw new NullPointerException();
    }
  }

  public static Connection getConnection(String url, String user, String password) throws SQLException {
    java.util.Properties info = new java.util.Properties();
    if (user != null) {
      info.put("user", user);
    }
    if (password != null) {
      info.put("password", password);
    }
    return (getConnection(url, info, Reflection.getCallerClass()));
  }
  //...
}
```

当我们把具体的 Driver 实现类（比如，com.mysql.cj.jdbc.Driver）注册到 DriverManager 之后，后续所有对 JDBC 接口的调用，都会委派到对具体的 Driver 实现类来执行。而 Driver 实现类都实现了相同的接口（java.sql.Driver ），这也是可以灵活切换 Driver 的原因。

![img](https://raw.githubusercontent.com/a1254898873/images/master/202203240116551.webp)





## 创建型模式

### 工厂模式

#### 定义

工厂方法模式是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。

![../_images/SimpleFactory.jpg](https://raw.githubusercontent.com/a1254898873/images/master/202203240116552.jpg)









#### 比较

简单工厂：将创建不同对象的逻辑放在一个工厂类中。

工厂方法：将创建不同对象的逻辑放在不同工厂类中，先用一个工厂类的工厂类得到某个工厂，在某这个工厂来创建对象。

这样讲区别就很明显了，如果创建对象的逻辑比较复杂，要做各种初始化操作，这时候使用工厂方法，能够将复杂的创建逻辑拆分到多个工厂类中；而创建对象的逻辑很简单，就没必要额外创建多个工厂类，直接使用简单工厂即可。









#### 应用

Calendar 类获取日历类对象

Calendar 抽象类，该类的子类有 BuddhistCalendar、JapaneseImperialCalendar、GregorianCalendar、RollingCalendar等

getInstance方法，根据参数获取一个Calendar子类对象，该方法实际将参数传给 createCalendar 方法，createCalendar 在根据参数通过 provider 或 switch 或者 if-else 创建相应的子类对象

以下为 Java8 中的 Calendar 类代码，Java7 中的实现为 if-else 方式

```java
public static Calendar getInstance(TimeZone zone, Locale aLocale) {
    return createCalendar(zone, aLocale);
}

private static Calendar createCalendar(TimeZone zone, Locale aLocale) {
    CalendarProvider provider = LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale).getCalendarProvider();
    if (provider != null) {
        try {
            return provider.getInstance(zone, aLocale);
        } catch (IllegalArgumentException iae) {
        }
    }

    Calendar cal = null;

    if (aLocale.hasExtensions()) {
        String caltype = aLocale.getUnicodeLocaleType("ca");
        if (caltype != null) {
            switch (caltype) {
                case "buddhist":
                    cal = new BuddhistCalendar(zone, aLocale); break;
                case "japanese":
                    cal = new JapaneseImperialCalendar(zone, aLocale); break;
                case "gregory":
                    cal = new GregorianCalendar(zone, aLocale); break;
            }
        }
    }
    if (cal == null) {
        if (aLocale.getLanguage() == "th" && aLocale.getCountry() == "TH") {
            cal = new BuddhistCalendar(zone, aLocale);
        } else if (aLocale.getVariant() == "JP" && aLocale.getLanguage() == "ja" && aLocale.getCountry() == "JP") {
            cal = new JapaneseImperialCalendar(zone, aLocale);
        } else {
            cal = new GregorianCalendar(zone, aLocale);
        }
    }
    return cal;
}
```



### 抽象工厂

#### 定义

抽象工厂模式是一种创建型设计模式， 它能创建一系列相关的对象， 而无需指定其具体类。

![抽象工厂模式的结构图](https://raw.githubusercontent.com/a1254898873/images/master/202203240116553.gif)





### 单例模式

#### 定义

单例模式是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。

单例模式有三个要点：

1. 构造方法私有化；
2. 实例化的变量引用私有化；
3. 获取实例的方法共有



![img](https://raw.githubusercontent.com/a1254898873/images/master/202203240116554.png)



#### 分类

1、饿汉式

```java
// 线程安全
public class Singleton {

    private final static Singleton INSTANCE = new Singleton();

    private Singleton(){}

    public static Singleton getInstance(){
        return INSTANCE;
    }
}

```

优点：简单，使用时没有延迟；在类装载时就完成实例化，天生的线程安全

缺点：没有懒加载，启动较慢；如果从始至终都没使用过这个实例，则会造成内存的浪费。



2、懒汉式

```java
// 线程不安全
public class Singleton {

    private static Singleton singleton;

    private Singleton() {}

    public static Singleton getInstance() {
        if (singleton == null) {
            singleton = new Singleton();
        }
        return singleton;
    }
}

```

优点：懒加载，启动速度快、如果从始至终都没使用过这个实例，则不会初始化该实力，可节约资源

缺点：多线程环境下线程不安全。if (singleton == null) 存在竞态条件，可能会有多个线程同时进入 if 语句，导致产生多个实例





### 建造者模式

建造者模式使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。

![img](https://raw.githubusercontent.com/a1254898873/images/master/202203240116555.png)



#### 实现

1. 在Computer 中创建一个静态内部类 Builder，然后将Computer 中的参数都复制到Builder类中。
2. 在Computer中创建一个private的构造函数，参数为Builder类型
3. 在Builder中创建一个`public`的构造函数，参数为Computer中必填的那些参数，cpu 和ram。
4. 在Builder中创建设置函数，对Computer中那些可选参数进行赋值，返回值为Builder类型的实例
5. 在Builder中创建一个`build()`方法，在其中构建Computer的实例并返回



```java
public class Computer {
    private final String cpu;//必须
    private final String ram;//必须
    private final int usbCount;//可选
    private final String keyboard;//可选
    private final String display;//可选

    private Computer(Builder builder){
        this.cpu=builder.cpu;
        this.ram=builder.ram;
        this.usbCount=builder.usbCount;
        this.keyboard=builder.keyboard;
        this.display=builder.display;
    }
    public static class Builder{
        private String cpu;//必须
        private String ram;//必须
        private int usbCount;//可选
        private String keyboard;//可选
        private String display;//可选

        public Builder(String cup,String ram){
            this.cpu=cup;
            this.ram=ram;
        }

        public Builder setUsbCount(int usbCount) {
            this.usbCount = usbCount;
            return this;
        }
        public Builder setKeyboard(String keyboard) {
            this.keyboard = keyboard;
            return this;
        }
        public Builder setDisplay(String display) {
            this.display = display;
            return this;
        }        
        public Computer build(){
            return new Computer(this);
        }
    }
  //省略getter方法
}
```

```java
Computer computer=new Computer.Builder("因特尔","三星")
                .setDisplay("三星24寸")
                .setKeyboard("罗技")
                .setUsbCount(2)
                .build();
```

使用lombok的@Builder注解可以自动给我们生成建造者模式代码,需要特别强调的是如果使用了@Builder注解就万万不要在加@AllArgsConstructor @NoArgsConstructor 这样的lombok注解了，这个注解会给类生成public的构造函数，破坏的建造者模式。



#### 应用

SpringSecurity中的建造者模式

我们使用 HttpSecurity 链式调用的方式去配置很多属性，比如配置我们需要的过滤器、自定义的过滤器等等，配置好后最终构建出所需的对象。





### 原型模式

#### 定义

原型模式是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。

![img](https://raw.githubusercontent.com/a1254898873/images/master/202203240116556.png)



1.浅拷贝：

（1）当类的成员变量是基本数据类型时，浅拷贝会复制该属性的值赋值给新对象。

（2）当成员变量是引用数据类型时，浅拷贝复制的是引用数据类型的地址值。它跟原对象指向的是一个内存地址，当变量修改，就相当于所有的都改了

2.深拷贝:

（1）当类的成员变量是基本数据类型时，浅拷贝会复制该属性的值赋值给新对象。

（2）当成员变量是引用数据类型时，深拷贝会给是引用数据类型的成员变量申请储存空间，并复制引用数据类型成员变量的对象。所以就不会对拷贝出的对象造成影响。



#### 实现

1.需要拷贝的原型类必须实现"java.lang.Cloneable"接口，然后重写Object类中的clone方法，从而才可以实现类的拷贝。

2.Cloneable是一个“标记接口”，所谓的标记接口就是该接口中没有任何内容。标记接口的作用就是为了给所有实现了该接口的类赋予一种特殊的标志。

3.只有当一个类实现了Cloneable接口后，该类才会被赋予调用重写自Object类的clone方法得权利。否则会抛出“CloneNotSupportedException”异常。

```java
//具体原型类
class Realizetype implements Cloneable{
   Realizetype(){
      System.out.println("具体原型创建成功！");
   }
   //重写Object类的clone方法
   public Object clone() throws CloneNotSupportedException{
      System.out.println("具体原型复制成功！");
      return (Realizetype)super.clone();
   }
}
 
//原型模式的测试类
public class PrototypeTest{
   public static void main(String[] args)throws CloneNotSupportedException{
      Realizetype obj1=new Realizetype();//原型创建
      Realizetype obj2=(Realizetype)obj1.clone();//原型复制
      System.out.println("obj1==obj2?"+(obj1==obj2));//结果为false
   }
}
```

